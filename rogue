#!/bin/bash
source $( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )/common/RogueArgs.sh "${@}"

#set -euo pipefail
set -ex
IFS=$'\n\t'
#script metadata values
script_name=$(basename "$0")
script_dir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
#Detect if sourced
(return 0 2>/dev/null) && sourced=true || sourced=false

if ! $sourced; then
  #do not use set -a because it will cause all these secret values to be sent to terminal
  #set -a      # turn on automatic exporting
  [ -f ${script_dir}/env ] && source ${script_dir}/env
  [ -f "$host_wd/env" ] && source "$host_wd/env"
  #set +a      # turn off automatic exporting
fi

make_all_executable () {
    dir=${1:-$PWD}
    pattern=${2:-*.sh}
    find $dir -type f -iname "$pattern" -exec chmod +x {} \;
}

git_pull () {
  git stash
  git pull
  git stash pop
  git submodule update --init --recursive --remote
}
install_docker () {
   set -euo pipefail
   $script_dir/common/install-docker.sh
   set +euo pipefail
}
docker_build () {
  local log; log="$(docker build . -t $project/$image:$tag $1)"
  if [ $? -ne 0 ]; then
    echo "Error building image = $project/$image:$tag" > /dev/stderr
    echo "$log" > /dev/stderr
  fi
}
export d_compose=(docker-compose)
if [ -z "${IS_ROGUE_CONTEXT}" ]; then
	if ! command -v docker &> /dev/null; then
	    header "Docker not found. Installing"
	    no_docker=true
	    install_docker
	fi
	if [ -x "$(command -v docker-compose)" ]; then
	    header "docker-compose (v1) is installed."
	    header " will attempt to use docker-compose but may have incompabitliby issues."
	    header "to force docker compose (v2) install. Run ${script_dir}/common/install-docker.sh"
	elif $(docker compose &>/dev/null) && [ $? -eq 0 ]; then
	    header "docker compose (v2) is installed."
	    d_compose=(docker compose)
	else
	    if [ -z "${no_docker}" ]; then
		echo "Please restart your computer"
		exit 1
	    fi
	    header "Docker compose not found. Installing"
            install_docker
	fi
fi

#if first variable == --help then print readme.md
if [ "$1" == "--help" ]; then
	# if glow exists then use that
	if command -v glow &> /dev/null; then
		glow "$script_dir/README.md"
	else
		cat "$script_dir/README.md"
	fi
	exit 0
fi

inpath=$1
# if [[ $inpath == ~* ]]; then
# 	#inpath="${inpath/#\~/$HOME}"
# 	echo "unaccepted path"
# 	exit 1
# fi
# if [[ $inpath == /* ]]; then
# 	#inpath="${inpath/#\/}"
# 	echo "unaccepted path"
# 	exit 1
# fi

#https://medium.com/oracledevs/creating-an-oracle-cloud-infrastructure-cli-toolkit-docker-image-35be0ca71aa

if [ "$1" == "--" ]; then
  case $2 in
    reset)
      cd ..
      rm -rf RogueSecrets/
      docker rmi $(docker images --filter=reference="rogueos/*:*" -q) -f
      git clone https://github.com/ktsuttlemyre/RogueSecrets.git
      cd RogueSecrets/
      chmod +x ./index.sh ./reset.sh
      #./index.sh
      ;;
    local | is_rogue_context | use_current_context )
      IS_ROGUE_CONTEXT=true
      ;;
    *)
      echo -n "unknown argument"
      ;;
  esac
fi

export DOCKER_DEFAULT_PLATFORM=linux/amd64

#if image not already here
#if [ -z "$(docker images -q $project/$image:$tag 2> /dev/null)" ]; then
#  docker_build
#else
#  #cache to rebuild image evey week hard rebuild every month
#  created_date="$(docker inspect -f '{{ .Created }}' $project/$image:$tag)"
#  created_week=$(date +'%V' -d +'%Y-%m-%dT%H:%M:%S' --date="$created_date")
#  created_month=$(date +'%m' -d +'%Y-%m-%dT%H:%M:%S' --date="$created_date")
#  current_week=$(date +'%V')
#  current_month=$(date +'%m')
#  if [ "$created_week" -ne "$current_week" ]; then
#    git_pull
#    [ "$created_month" -ne "$current_month" ] && cache='--no-cache'
#    docker_build $cache
#  fi
#fi

#make all paths relative if absolute
inpath=${inpath//$PWD/.}
#remove ./ from relative path to make a bare relative path
inpath=${inpath#'./'}
#remove cli
inpath=${inpath#'cli'}
#remove RogueCLI
inpath=${inpath#'RogueCLI'}

absolute_path="$PWD/$inpath"
relative_path="./$inpath"
array_path=($(echo "$relative_path" | sed 's/\//\n/g'))

if [[ -d "$inpath" ]] || [[ ! -x "$inpath" ]]; then
    header "Error must provide an executable file"
    header "got arguments ${@}"
    exit 1
fi

#if is_context isn't set then find the context to run this command
if [ -z "${IS_ROGUE_CONTEXT}" ]; then
	export PID=$$
	export USERNAME=${USER:-$(whoami)}
	export PUID=${UID:-$(id -u $USERNAME)}
	export PGID=$(id -g $USERNAME)
	
	export PARENT=$(dirname "$PWD")
	export ENTRYPOINT="${@}"
	#export CMD="${@:2}"
	
	full_path=$(realpath "$inpath")
	
	envvars=$(env || printenv)

	#create ramdisk
	RAMDISK="RogueCLI_ramdisk_$$"
	#TODO run local scripts through rougue cause its neat
	#IS_ROGUE_CONTEXT=true ./rogue ./create/ramdisk.sh 250M "$RAMDISK" -- local
	#./rogue ./create/ramdisk.sh 250M "$RAMDISK" -- local
	./create/ramdisk.sh 250M "$RAMDISK"
	#Create dynamic docker-compose.yaml
	service="${image}"

	#Add env vars to session (iterate from parent to child)
	path=''
	for path_e in ${array_path[@]}; do
    		path="$path$path_e"
		for file in $(shopt -s nullglob; echo $path/*compose.env); do
		    if [ -z "$file" ]; then continue; fi
		    echo "$file"
		    set -a      # turn on automatic exporting
		    source "$file"
		    set +a      # turn off automatic exporting
		done
		path="$path/"
	done

	#generate docker_compose_yaml (iterate from parent to child)
	docker_compose_yaml=''
	path=''
	for path_e in ${array_path[@]}; do
    		path="$path$path_e"
		for file in $(shopt -s nullglob; echo $path/*compose.*); do
		    if [ -z "$file" ]; then continue; fi
		    if [[ $file == *.yml  || $file == *.yaml ]]; then
		        echo "DEBUGG::: $docker_compose_yaml"
		        echo "DEBUGG::: $envvars"
		        echo "DEBUGG::: $file"
		        if [ -z "${docker_compose_yaml}" ]; then
			    docker_compose_yaml="$(${d_compose[@]} -f <( envsubst < "$file" ) --env-file <(echo "$envvars") config)"
		        else
			    docker_compose_yaml="$(${d_compose[@]} -f <(envsubst < "$docker_compose_yaml") -f <( envsubst < "$file" ) --env-file <(echo "$envvars") config)"
			fi
		    fi
		done
		path="$path/"
	done
	echo $envvars
	echo "============"
	echo "============"
	echo "$docker_compose_yaml"
	exit
	
	${d_compose[@]} "${docker_compose_yamls[@]}" --env-file <(env) config 
	#d_compose_args=${docker_compose_yamls[@]} --env-file <(env)
	# ${d_compose[@]} ${docker_compose_yamls[@]} --env-file <(env) config | ${d_compose[@]} -f - up --pull always --build
	#run
	${d_compose[@]} ${docker_compose_yamls[@]} --env-file <(env) config | ${d_compose[@]} -f - pull
	#get workdir from image
	#WORKDIR=$(docker image inspect -f '{{.Config.WorkingDir}}' "${image}")

	debugger 
	if [ -z "${registry}" ]; then
		${d_compose[@]} ${docker_compose_yamls[@]} --env-file <(env) config | ${d_compose[@]} -f - run --remove-orphans --env IS_ROGUE_CONTEXT=true --build "${service}"
	else
		${d_compose[@]} ${docker_compose_yamls[@]} --env-file <(env) config | ${d_compose[@]} -f - run --remove-orphans --env IS_ROGUE_CONTEXT=true "${service}"
	fi
	if ! [ -z "$is_service" ]; then
		${d_compose[@]} ${docker_compose_yamls[@]} --env-file <(env) config | ${d_compose[@]} -f - down
	fi
	rogue_envvars="$RAMDISK.env"
	if [ -f rogue_envvars ]; then
		header "Exporting secrets to current session"
		case "$(uname)" in
			LINUX) export $(grep -v '^#' $rogue_envvars | xargs -d 'n' ) ;;
			*) echo "Error exporing values from container"  ;;
		esac
		rm "$rogue_envvars"
	fi
 	sudo umount "$RAMDISK"

	exit 0
fi


path=''
for path_e in ${array_path[@]}; do
    path="$path$path_e"

    #check if path is a directory or file
    if [[ -d $path ]]; then
        #iterate all files in path that are hidden files and source them
        for file in $(shopt -s nullglob; echo $path/*); do
	    if [ -z "$file" ]; then continue; fi
            if [[ ! -f $file ]]; then
                continue
            fi
            #if file ends with .sh or .env
            if [[ $file == *.sh || $file == *.env ]]; then
                source $file
            else
                env $file
            fi
        done
	path="$path/"
    elif [[ -f $path ]]; then #if path variable is a file then exec it
	exec env $path "${@:2}" </dev/tty
	# if test ! -t 0; then
	#     #echo "Read from stdin"
	#     #currently doesnt work with decrypt
	#     exec env $path "${@:2}" < /dev/stdin # or < /proc/$$/fd/0 for stdin
	# else
	# 	exec env $path "${@:2}" < /dev/tty # or < /proc/$$/fd/0 for stdin
	# fi
	#if it fails then exit with the same error number as the previous command
	if [ $? -ne 0 ]; then
	exit $?
	fi
	break
    else
	header "Error unknown path type"
    fi
done




